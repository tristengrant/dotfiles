/* See LICENSE file for copyright and license details. */
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <dirent.h>
#include <sys/stat.h>

#include "arg.h"
#include "slstatus.h"
#include "util.h"

struct arg {
	const char *(*func)(const char *);
	const char *fmt;
	const char *args;
};

char buf[1024];
static volatile sig_atomic_t done;
static Display *dpy;

#include "config.h"

/* --- Maximum number of modules --- */
#define MAX_MODULES 8

static struct arg modules[MAX_MODULES];
static size_t modules_len = 0;
static unsigned int update_interval;

/* --- Helper functions --- */
static int file_exists(const char *path) {
	struct stat st;
	return stat(path, &st) == 0;
}

static void add_battery_modules(void) {
	DIR *dir = opendir("/sys/class/power_supply");
	if (!dir) return;

	struct dirent *ent;
	while ((ent = readdir(dir)) != NULL) {
		if (strncmp(ent->d_name, "BAT", 3) == 0) {
			char path[256];
			snprintf(path, sizeof(path), "/sys/class/power_supply/%s/capacity", ent->d_name);
			if (file_exists(path)) {
				if (modules_len < MAX_MODULES)
					modules[modules_len++] = (struct arg){ battery_perc, "Bat%s %s%%  ", ent->d_name };
				update_interval = 2000; // slower for battery
			}
		}
	}
	closedir(dir);
}

static void add_alsa_modules(void) {
	DIR *dir = opendir("/dev");
	if (!dir) return;

	struct dirent *ent;
	while ((ent = readdir(dir)) != NULL) {
		if (strncmp(ent->d_name, "mixer", 5) == 0) {
			char path[256];
			snprintf(path, sizeof(path), "/dev/%s", ent->d_name);
			if (file_exists(path)) {
				if (modules_len < MAX_MODULES)
					modules[modules_len++] = (struct arg){ vol_perc, "Vol %s%%  ", strdup(path) };
				update_interval = 1000; // faster for volume
			}
		}
	}
	closedir(dir);
}

/* --- Signal handler --- */
static void terminate(const int signo) {
	if (signo != SIGUSR1)
		done = 1;
}

static void difftimespec(struct timespec *res, struct timespec *a, struct timespec *b) {
	res->tv_sec = a->tv_sec - b->tv_sec - (a->tv_nsec < b->tv_nsec);
	res->tv_nsec = a->tv_nsec - b->tv_nsec + (a->tv_nsec < b->tv_nsec) * 1E9;
}

static void usage(void) {
	die("usage: %s [-v] [-s] [-1]", argv0);
}

int main(int argc, char *argv[]) {
	struct sigaction act;
	struct timespec start, current, diff, intspec, wait;
	size_t i, len;
	int sflag, ret;
	char status[MAXLEN];
	const char *res;

	sflag = 0;
	ARGBEGIN {
	case 'v':
		die("slstatus-"VERSION);
	case '1':
		done = 1;
		/* FALLTHROUGH */
	case 's':
		sflag = 1;
		break;
	default:
		usage();
	} ARGEND

	if (argc)
		usage();

	/* --- Detect modules --- */
	modules_len = 0;
	update_interval = interval; // default from config.h

	add_battery_modules();
	add_alsa_modules();

	// Always add datetime at the end
	if (modules_len < MAX_MODULES)
		modules[modules_len++] = (struct arg){ datetime, "%s", " %a %b %d %I:%M%p " };

	/* --- Setup signal handlers --- */
	memset(&act, 0, sizeof(act));
	act.sa_handler = terminate;
	sigaction(SIGINT,  &act, NULL);
	sigaction(SIGTERM, &act, NULL);
	act.sa_flags |= SA_RESTART;
	sigaction(SIGUSR1, &act, NULL);

	/* --- Open X display if needed --- */
	if (!sflag && !(dpy = XOpenDisplay(NULL)))
		die("XOpenDisplay: Failed to open display");

	do {
		if (clock_gettime(CLOCK_MONOTONIC, &start) < 0)
			die("clock_gettime:");

		status[0] = '\0';
		for (i = len = 0; i < modules_len; i++) {
			res = modules[i].func(modules[i].args);
			if (!res)
				res = unknown_str;

			if ((ret = esnprintf(status + len, sizeof(status) - len,
			                     modules[i].fmt, res)) < 0)
				break;

			len += ret;
		}

		if (sflag) {
			puts(status);
			fflush(stdout);
			if (ferror(stdout))
				die("puts:");
		} else {
			if (XStoreName(dpy, DefaultRootWindow(dpy), status) < 0)
				die("XStoreName: Allocation failed");
			XFlush(dpy);
		}

		if (!done) {
			if (clock_gettime(CLOCK_MONOTONIC, &current) < 0)
				die("clock_gettime:");
			difftimespec(&diff, &current, &start);

			intspec.tv_sec = update_interval / 1000;
			intspec.tv_nsec = (update_interval % 1000) * 1E6;
			difftimespec(&wait, &intspec, &diff);

			if (wait.tv_sec >= 0 &&
			    nanosleep(&wait, NULL) < 0 &&
			    errno != EINTR)
				die("nanosleep:");
		}
	} while (!done);

	if (!sflag) {
		XStoreName(dpy, DefaultRootWindow(dpy), NULL);
		if (XCloseDisplay(dpy) < 0)
			die("XCloseDisplay: Failed to close display");
	}

	return 0;
}
